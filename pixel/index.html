<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TinyYOLO</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"> </script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
</head>
<body>
<!-- <canvas id="myCanvas" width="2" height="2"> -->
<!-- <canvas id="myCanvas" width="2" height="2"> -->
<!-- <canvas id="myCanvas" width="40" height="50"> -->
<canvas id="myCanvas" width="170" height="135">
    <!-- <img src="./01.png" id="img" alt=""/> -->
    <!-- <img src="./px4.jpg" id="img" alt=""/> -->
    <!-- <img src="./03.jpg" id="img" alt=""/> -->
    <img src="./04.jpg" id="img" alt=""/>
</canvas>

<script>
    // 通过js获取图像数据
    var canvas_obj = document.getElementById("myCanvas");   // 获取canvas标签对象
    var canvasWidth = canvas_obj.width;
    console.log(canvasWidth)
    var ctx = canvas_obj.getContext("2d");                  // 设置在画布上绘图的环境
    var img_obj = document.getElementById("img");           // 获取img标签对象
    img_obj.onload = function(){

    
        ctx.drawImage(img_obj, 0, 0);                           // 将图片绘制到画布上
        var color = [255,0,0]
        var deviation = 5;
        var nearPix = 5;


        var imgData_obj = ctx.getImageData(0,0,canvas_obj.width,canvas_obj.height);    // 获取画布上的图像像素矩阵
        var imgData = imgData_obj.data;     // 获取到的数据为一维数组，包含图像的RGBA四个通道数据
        // console.log(imgData);

        // 将获取到的图像数据去除A通道
        var imgArr = [];
        for(var i=0; i<imgData.length; i += 4){
            imgArr.push([imgData[i], imgData[i+1], imgData[i+2]])
        }
        console.log(imgArr)

        //找到符合像素点索引值
        var pixelIndex = []
        for(var i=0; i<imgArr.length; i++){
            var imgRange = getRange(imgArr[i])
            // console.log(imgRange)
            if(imgRange.includes(color.join("-"))){
                pixelIndex.push({rgb:imgArr[i],index:i,left:i%canvasWidth,top:parseInt(i/canvasWidth)})
            }
        }
        console.log(pixelIndex)
        // console.log(pixelIndex[0]%40) //left
        // console.log(parseInt(pixelIndex[0]/40)) //top
        
        //找到符合左上顶点索引值
        var lineArr = []
        var vertexIndex = []
        var vertex = pixelIndex[0]
        var _left = null
        var _top = null
        var _index = null
        var currentIndex = 0;
        for(var i=0; i<pixelIndex.length; i++){
            // vertex.push(pixelIndex[i])
            // if(vertexIndex.length == 0){//记录首个顶点
            //     vertexIndex.push(pixelIndex[i])
            // }
            // if(_left == null){
            //     _left = pixelIndex[i].left
            // }
            // if(_top == null){
            //     _top = pixelIndex[i].top
            // }
            if(_index == null){
                _index = pixelIndex[i].index
                lineArr[currentIndex] = [];
                lineArr[currentIndex].push(pixelIndex[i]);
            }
            
            if(pixelIndex[i].index - _index < nearPix ){  
                lineArr[currentIndex].push(pixelIndex[i]);
                // if( pixelIndex[i].left - _left < 3 ){//代表横向相邻两个点
                    
                // }else{

                // }
                // _left = pixelIndex[i].left
                // _top = pixelIndex[i].top
            }else{//代表换行了
                currentIndex++;
                lineArr[currentIndex] = [];
                lineArr[currentIndex].push(pixelIndex[i]);
            }
            _index = pixelIndex[i].index

            // if(pixelIndex[i].top == _top &&  (pixelIndex[i].left - _left) < 3 ){ //代表横向相邻两个点            
            //     _left = pixelIndex[i].left
            //     _top = pixelIndex[i].top
            // }else{//代表换行了

            // }


            // if(Math.abs(pixelIndex[i].left - vertex.left) > 5 ){

            // }
        }

        console.log(lineArr);

        //找到符合像素块点索引值
        var rects = []
        var currentIndex = 0
        var tempPorint = null
        for(var i=0; i<lineArr.length; i++){

            if(rects.length == 0){//记录首个顶点
                rects[currentIndex] = []
                rects[currentIndex].push(lineArr[i]);
                tempPorint = lineArr[i][0]
            }

            if(   Math.abs(lineArr[i][0].left - tempPorint.left) < nearPix &&  Math.abs(lineArr[i][0].top - tempPorint.top) < nearPix  ){
                rects[currentIndex].push(lineArr[i]);
            }else{
                currentIndex++;
                rects[currentIndex].push(lineArr[i]);
                tempPorint = lineArr[i][0]
            }
        }


        function getRange(color){
            var r = []
            for(var i=-deviation; i<=deviation; i++){
                var a = color[0]+i
                if(a < 0 ) a = 0
                if(a > 255 ) a = 255
                var b = color[1]+i
                if(b < 0 ) b = 0
                if(b > 255 ) b = 255
                var c = color[2]+i
                if(c < 0 ) c = 0
                if(c > 255 ) c = 255
                
                if(color[0]+i >= 0 && color[0]+i <= 255){
                    
                }
                r.push(  a+"-"+color[1]+"-"+color[2]  );
                r.push(  color[0]+"-"+b+"-"+color[2]  );
                r.push(  color[0]+"-"+color[1]+"-"+c  );
                r.push(  a+"-"+b+"-"+color[2]  );
                r.push(  color[0]+"-"+b+"-"+c  );
                r.push(  a+"-"+color[1]+"-"+c  );
                r.push(  a+"-"+b+"-"+c  );
            }
            return r
        }

        // // 将js数组转化为tensor数据，并reshape
        // var imgMat = tf.tensor(imgArr);
        // var img = imgMat.reshape([1,448, 448, 3]);

        // const MODEL_URL = './web_model/model.json';             // 模型文件名
        // async function fun(){	                                // 预测函数
        //     const model = await tf.loadGraphModel(MODEL_URL);	// 加载图模型
        //     var predictData = model.predict(img);               // 预测
        //     console.log(predictData.shape);
        //     predictData.print()
        //     }

        // fun()	//调用函数
    }
</script>
</body>
</html>